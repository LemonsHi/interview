# 常见前端面试 - Node 篇

## 2018-11-05

### Buffer 内存分配与性能优化

`Buffer` 是一个典型的 `javascript` 与 `C++` 结合的模块，与性能有关的用 `C++` 来实现，`javascript` 负责衔接和提供接口。

**特点：**
- `Buffer` 所占的内存是 *独立于 `V8` 堆内存之外的内存*，通过 `C++` 层面实现内存申请、`javascript` 分配内存。
- `8KB` 问题：使用 `Buffer.alloc(size)` 请求一个 `Buffer` 内存时，`Buffer` 会以 `8KB 为界限` 来判断分配的是大对象还是小对象，*小对象存入剩余内存池，不够再申请一个 `8KB` 的内存池；大对象直接采用 `C++` 层面申请的内存。*

**优化：**
- 对于一个大尺寸对象，申请一个大内存比申请众多小内存池快很多。

### Stream 与 Buffer 关系

流是能统一描述所有常见输入输出类型的模型，是顺序读写字节序列的抽象表示。

数据从 A 端流向 B 端与从 B 端流向 A 端是不一样的，因此，流是有方向的。

**假设：** A 端输入数据到 B 端，则：
- 对 B 就是输入流，得到的对象就是可读流。
- 对 A 就是输出端、得到的对象是可写流。

在 `node` 中，这些流中的数据就是 `Buffer` 对象，可读、可写流会将数据存储到内部的缓存中，等待被消费。

`Duplex` 和 `Transform` 则是都维护了 *两个相互独立的缓存* 用于读和写。 在维持了合理高效的数据流的同时，也使得对于读和写可以独立进行而互不影响。

**注：** `node` 中，`Stream` 有四种流类型：`Readable` - 可读操作；`Writeable` - 可写操作；`Duplex` - 可读写操作；`Transform` - 操作被写入数据，然后读出结果。这四种流都是 `EventEmitter` 的实例，就意味着都有 `data、error、end、finish` 四个事件。

**注：** 由于输入与输出的速度不一致导致的问题：*缓存区爆仓*，存区是有大小的，一旦写的内容超过这个大小就会出现 *缓存区爆仓* 问题。因此，提供了一个 `drain` 事件，具体意义是：写的内容超过这个大小，`write` 方法就会返回 `false`，表示写入停止，这时如果继续 `read` 完缓存区数据，缓存区被排空，就会触发 `drain` 事件，可以这样来防止缓存区爆仓。

**管道流(pipe)：** 可以处理 *缓存区爆仓* 问题，其实现原理：如果超出缓存区大小，将调用 `pause` 方法，暂停读取，等读完缓存区数据触发 `drain` 事件，在调用 `resume` 恢复读取。

`pipe` 不仅可以作为通道，还能很好的控制管道里的流，控制读和写的平衡，不让任一方过度操作。另外，`pipe` 可以监听可读流的 `data、end` 事件，这样就可以构建快速的响应。

```javascript
rs.on('data',function(chunk){
  // chunk 读到的内容
  let flag = ws.write(chunk);
  if(!flag){
    //暂停读取
    rs.pause();
  }
});
ws.on('drain',function(){
  //当缓存区充满，并且被排开后触发drain事件
  //恢复读取
  rs.resume();
});
``````
