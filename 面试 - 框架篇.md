# 常见前端面试 - 编程篇

## 2018-10-28

### Vue 篇

1. Vue的双向数据绑定原理是什么？

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter ， getter ，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：

- 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter
这样的话，给这个对象的某个值赋值，就会触发 setter ，那么就能监听到了数据变化
- 第二步： compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
- 第三步： Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
  - 1、在自身实例化时往属性订阅器 (dep) 里面添加自己
  - 2、自身必须有一个 update() 方法
  - 3、待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。
- 第四步： MVVM 作为数据绑定的入口，整合 Observer 、 Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化 (input)  -> 数据 model 变更的双向绑定效果。

2. vue生命周期的理解？

总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后

创建前/后：在 beforeCreated 阶段， vue 实例的挂载元素 $el 和数据对象 data 都为 undefined ，还未初始化。在 created 阶段， vue 实例的数据对象 data 有了， $el 还没有。

载入前/后：在 beforeMount 阶段， vue 实例的 $el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成， data.message 成功渲染。

更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。

销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在

3. Vue.js 的 template 编译的理解？

简而言之，就是先转化成 AST 树，再得到的 render 函数返回 VNode （ Vue 的虚拟 DOM 节点）
详情步骤：

首先，通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即源代码的抽象语法结构的树状表现形式）， compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option 。
然后， AST 会经过 generate （将AST语法树转化成render funtion字符串的过程）得到 render 函数， render 的返回值是VNode， VNode 是 Vue 的虚拟DOM节点，里面有（标签名、子节点、文本等等）

**AST 特点**

- 给编译器后端提供了清晰，统一的接口。即使是前端采用了不同的文法，都只需要改变前端代码，而不用连累到后端。即减少了工作量，也提高的编译器的可维护性。
- 不依赖于语言的细节。

<div align=center>

![](https://raw.githubusercontent.com/zoro-web/blog/master/img/vue-template(1).png)

</div>


4. Vue 中的 MVVM 模式

MVVM 全称是 Model-View-ViewModel

Vue 是以数据为驱动的， Vue 自身将 DOM 和数据进行绑定，一旦创建绑定， DOM 和数据将保持同步，每当数据发生变化， DOM 会跟着变化。 ViewModel 是 Vue 的核心，它是 Vue 的一个实例。 Vue 实例时作用域某个 HTML 元素上的这个 HTML 元素可以是 body ，也可以是某个 id 所指代的元素。

DOMListeners 和 DataBindings 是实现双向绑定的关键。 DOMListeners 监听页面所有 View 层 DOM 元素的变化，当发生变化， Model 层的数据随之变化； DataBindings 监听 Model 层的数据，当数据发生变化， View 层的 DOM 元素随之变化。

### React 篇

1. React 生命周期

<div align=center>

![](https://user-gold-cdn.xitu.io/2017/11/11/88e11709488aeea3f9c6595ee4083bf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

</div>

2. React 事件机制

React 事件并没有原生的绑定在真实的DOM上，而是使用了行为委托方式实现事件机制。

React 并没有使用原生的浏览器事件，而是在基于 Virtual DOM 的基础上实现了合成事件 (SyntheticEvent) ，事件处理程序接收到的是 SyntheticEvent 的实例。 SyntheticEvent 完全符合 W3C 的标准，因此在事件层次上具有浏览器兼容性，与原生的浏览器事件一样拥有同样的接口，可以通过 stopPropagation() 和 preventDefault() 相应的中断。如果需要访问当原生的事件对象，可以通过引用 nativeEvent 获得。

<div align=center>

![](https://image-static.segmentfault.com/359/299/3592996693-58d13862179ab_articlex)

</div>

- 事件注册: React 在组件加载 (mount) 和更新 (update) 时,其中的 ReactDOMComponent 会对传入的事件属性进行处理，对相关事件进行注册和存储。 document 中注册的事件不处理具体的事件，仅对事件进行分发。 ReactBrowserEventEmitter 作为事件注册入口，担负着事件注册和事件触发。注册事件的回调函数由 EventPluginHub 来统一管理，根据事件的类型 (type) 和组件标识 (_rootNodeID) 为key唯一标识事件并进行存储。

- 事件执行: 事件执行时，document 上绑定事件 ReactEventListener.dispatchEvent 会对事件进行分发，根据之前存储的类型 (type) 和组件标识 (_rootNodeID) 找到触发事件的组件。 ReactEventEmitter 利用 EventPluginHub 中注入 (inject) 的 plugins (例如:SimpleEventPlugin、EnterLeaveEventPlugin) 会将原生的 DOM 事件转化成合成的事件，然后批量执行存储的回调函，回调函数的执行分为两步，第一步是将所有的合成事件放到事件队列里面，第二步是逐个执行。需要注意的是，浏览器原生会为每个事件的每个 listener 创建一个事件对象，可以从这个事件对象获取到事件的引用。这会造成高额的内存分配，React 在启动时就会为每种对象分配内存池，用到某一个事件对象时就可以从这个内存池进行复用，节省内存。

3. React合成事件理解

如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。 React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层—— SyntheticEvent 。

- 当用户在为 onClick 添加函数时， React 并没有将 Click 事件绑定在 DOM 上面。
- 而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时， React 将事件内容封装交给中间层 SyntheticEvent （负责所有事件合成）
- 所以当事件触发的时候，对使用统一的分发函数 dispatchEvent 将指定函数执行。

4. setState 原理

<div align=center>

![](https://pic3.zhimg.com/80/4fd1a155faedff00910dfabe5de143fc_hd.jpg)

</div>

```javascript
function enqueueUpdate(component) {
  // ...

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

var batchingStrategy = {
  isBatchingUpdates: false,

  batchedUpdates: function(callback, a, b, c, d, e) {
    // ...
    batchingStrategy.isBatchingUpdates = true;

    transaction.perform(callback, null, a, b, c, d, e);
  }
};
```

React 在初始化的时候，为了防止 state 的重复改变，调用 batchedUpdates 将， 组件放入 dirtyComponents 中，在结束的时候更新。

### AngularJS 篇

1. AngularJS 流程

<div align=center>

![](https://upload-images.jianshu.io/upload_images/1288413-5fe3ab053dd16b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/730/format/webp)

</div>

2. angular 的数据绑定采用什么机制？详述原理

脏检查机制。双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。

原理就是，Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。

- DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
- XHR响应事件 ( $http )
- 浏览器Location变更事件 ( $location )
- Timer事件( $timeout , $interval )
- 执行 $digest() 或 $apply()

防止模型的更新导致其他模型的变化，因此 $digest 会循环, 但 $digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。

3. angular 的 “依赖注入”

AngularJS 是通过构造函数的参数名字来推断依赖服务名称的，通过 toString() 来找到这个定义的 function 对应的字符串，然后用正则解析出其中的参数（依赖项），再去依赖映射中取到对应的依赖，实例化之后传入。

因为 AngularJS 的 injector 是假设函数的参数名就是依赖的名字，然后去查找依赖项，那如果按前面栗子中那样注入依赖，代码压缩后（参数被重命名了），就无法查找到依赖项了。因此可以通过：数组注释法、显式 $inject 来处理该问题。

4. factory、service 和 provider 是什么关系？

factory: 把 service 的方法和数据放在一个对象里，并返回这个对象

service: 通过构造函数方式创建 service，返回一个实例化对象

provider: 创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容

从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，返回其 $get 中定义的内容。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写，你懂的）；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。
